/**
 *  This code is part of the lab exercises for the Compilers course
 *  at Harokopio University of Athens, Dept. of Informatics and Telematics.
 */

import java_cup.runtime.Symbol;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

parser code
{:
    private static final Logger LOGGER = LoggerFactory.getLogger(parser.class);

    /** Report a non fatal error (or warning).
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_error(String message, Object info)
    {
        String error = "";
        if (!(info instanceof Symbol))
            info = cur_token;
        if(info instanceof Symbol) {
            int line = ((Symbol)info).left;
            int column = ((Symbol)info).right;
            error = line  + ":" + column;
        }
        error += ": " + message;
        LOGGER.error(error);
    }

    /** Report a fatal error.
     *
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    public void report_fatal_error(String   message, Object   info) throws java.lang.Exception
    {
        /* stop parsing (not really necessary since we throw an exception, but) */
        done_parsing();

        /* use the normal error message reporting to put out the message */
        report_error(message, info);

        /* throw an exception */
        throw new Exception("Can't recover from previous error(s)");
    }

    public int getLine() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.left;
    }

    public int getColumn() {
        Symbol symbol = (Symbol) cur_token;
        return symbol.right;
    }
:};

/* voithane to cup na ftiaksi to enumeration */
terminal java.lang.String IDENTIFIER;       // name
terminal PRINT, DO, WHILE;
terminal IF, ELSE;
terminal VOID, RETURN, BREAK , CONTINUE, STRUCT;
// terminal BOOL, FLOAT, INT, CHAR;
terminal LPAREN, RPAREN, SEMICOLON;
terminal EQ;
terminal TIMES, DIVISION, MODULUS;
terminal PLUS, MINUS, UMINUS;

terminal LT, GT, LE, GE, EQEQ, NEQ;
terminal LCURLY, RCURLY;
terminal RIGHT_SQUARE, LEFT_SQUARE;
terminal LAND, LOR, LNOT; 
terminal DOT, COMMA;

terminal java.lang.Integer   INTEGER_LITERAL;
terminal java.lang.Double    DOUBLE_LITERAL;
terminal java.lang.String    STRING_LITERAL;
terminal java.lang.Boolean   BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;

terminal INTEGER_SPECIFIER, BOOLEAN_SPECIFIER, DOUBLE_SPECIFIER, CHARACTER_SPECIFIER;

non terminal Expression Expr;
non terminal Statement Stmt;
non terminal List<Statement> StmtList;
non terminal CompUnit CompUnit;
non terminal CompoundStmt;
non terminal ExprList;
non terminal VariableDefinition;
non terminal StructDefinition;
non terminal TypeSpecifier;
non terminal ParameterDeclaration;
non terminal ParameterList;
non terminal FunctionDefinition;
non terminal Definitions;
non terminal VariableDefinitions;

//precedence left INTEGER_SPECIFIER, BOOLEAN_SPECIFIER, DOUBLE_SPECIFIER, CHARACTER_SPECIFIER, STRUCT, VOID;
precedence left LOR;
precedence left LAND;
precedence left EQEQ, NEQ;
precedence left LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVISION, MODULUS;
precedence right UMINUS, LNOT;
precedence left LPAREN, RPAREN, LEFT_SQUARE, RIGHT_SQUARE, DOT;

start with CompUnit;

/* whitespace OR statement list */
CompUnit               ::= Definitions:d
                           {:
                                RESULT = new CompUnit(d);
                                RESULT.setLine(dleft);
                                RESULT.setColumn(dright);
                            :}
                         | Definitions:d CompUnit:cu
                           {:
                                d.add(cu);
                                RESULT = d;
                            :}
                         ;


Definitions            ::= VariableDefinition:vd
                           {:
                                RESULT = new VariableDefinition(vd);
                                RESULT.setLine(vdleft);
                                RESULT.setColumn(vdright);
                            :}
                         | FunctionDefinition:
                           {:
                                RESULT = new FunctionDefinition(fd);
                                RESULT.setLine(fdleft);
                                RESULT.setColumn(fdright);
                            :}
                         | StructDefinition:sd
                           {:
                                RESULT = new StructDefinition(sd);
                                RESULT.setLine(sdleft);
                                RESULT.setColumn(sdright);
                            :}
                         ;

FunctionDefinition     ::= TypeSpecifier:ts IDENTIFIER:i LPAREN ParameterList:pl RPAREN LCURLY StmtList:sl RCURLY
                           {:
                                RESULT = ts;
                                RESULT.setLine(tsleft);
                                RESULT.setColumn(tsright);
                            :}
                         ;

ParameterList          ::= 
                         | ParameterDeclaration/* TODO */
                         | ParameterList COMMA ParameterDeclaration/* TODO */
                         ;

ParameterDeclaration   ::= TypeSpecifier IDENTIFIER/* TODO */
                         | TypeSpecifier LEFT_SQUARE RIGHT_SQUARE IDENTIFIER/* TODO */
                         ;
TypeSpecifier          ::= CHARACTER_SPECIFIER {: RESULT = new Type("char") :}
                         | BOOLEAN_SPECIFIER {: RESULT = new Type("bool") :}
                         | INTEGER_SPECIFIER {: RESULT = new Type("int") :}
                         | DOUBLE_SPECIFIER {: RESULT = new Type("float") :}
                         | VOID {: RESULT = new Type("void") :}
                         | STRUCT IDENTIFIER {: RESULT = new Type("struct") :}
                         ;

VariableDefinitions    ::= VariableDefinition
                         | VariableDefinitions VariableDefinition
                         ;

VariableDefinition     ::= TypeSpecifier IDENTIFIER SEMICOLON
                         | TypeSpecifier IDENTIFIER LEFT_SQUARE INTEGER_LITERAL RIGHT_SQUARE SEMICOLON
                         ;

StructDefinition       ::= STRUCT IDENTIFIER LCURLY VariableDefinitions RCURLY SEMICOLON
                         ;
StmtList               ::= Stmt:s
                           {:
                                RESULT = new ArrayList<Statement>();
                                RESULT.add(s);
                           :}
                        | StmtList:sl Stmt:s
                          {:
                                sl.add(s);
                                RESULT = sl;
                          :}
                        ;  
Stmt                   ::= PRINT:p LPAREN Expr:e RPAREN SEMICOLON
                            {:
                                RESULT = new PrintStatement(e);
                                RESULT.setLine(pleft);
                                RESULT.setColumn(pright);
                            :}
                         | IDENTIFIER:id EQ Expr:e SEMICOLON
                            {:
                                RESULT = new AssignmentStatement(id, e);
                                RESULT.setLine(idleft);
                                RESULT.setColumn(idright);
                            :}
                         | CompoundStmt /* TODO */
                         | DO:d Stmt:s WHILE LPAREN Expr:e RPAREN SEMICOLON
                            {:
                                RESULT = new DoWhileStatement(e, s);
                                RESULT.setLine(dleft);
                                RESULT.setColumn(dright);
                            :}
                         | WHILE:w LPAREN Expr:e RPAREN Stmt:s
                            {:
                                RESULT = new WhileStatement(e, s);
                                RESULT.setLine(wleft);
                                RESULT.setColumn(wright);
                            :}
                         | IF:i LPAREN Expr:e RPAREN Stmt:s
                            {:
                                RESULT = new IfStatement(e, s);
                                RESULT.setLine(ileft);
                                RESULT.setColumn(iright);
                            :}
                         | IF:i LPAREN Expr:e RPAREN Stmt:s1 ELSE Stmt:s2
                            {:
                                RESULT = new IfElseStatement(e, s1, s2);
                                RESULT.setLine(ileft);
                                RESULT.setColumn(iright);
                            :}
                         | Expr:e SEMICOLON //idk
                            {:
                                RESULT = new Expression(e);
                                RESULT.setLine(ileft);
                                RESULT.setColumn(iright);
                            :}
                         | RETURN Expr SEMICOLON /* TODO */
                         | RETURN SEMICOLON /* TODO */
                         | Expr EQ Expr SEMICOLON /* TODO */
                         | BREAK SEMICOLON /* TODO */
                         | CONTINUE SEMICOLON /* TODO */
                         | VariableDefinition /* TODO */
                         ;
Expr                   ::= INTEGER_LITERAL:l
                            {:
                                RESULT = new IntegerLiteralExpression(l);
                                RESULT.setLine(lleft);
                                RESULT.setColumn(lright);
                            :}
                         | DOUBLE_LITERAL:l
                            {:
                                RESULT = new DoubleLiteralExpression(l);
                                RESULT.setLine(lleft);
                                RESULT.setColumn(lright);
                            :}
                         | STRING_LITERAL:s
                            {:
                                RESULT = new StringLiteralExpression(s);
                                RESULT.setLine(sleft);
                                RESULT.setColumn(sright);
                            :}
                         | BOOLEAN_LITERAL /* TODO */
                         | CHARACTER_LITERAL /* TODO */
                         | IDENTIFIER:id
                            {:
                                RESULT = new IdentifierExpression(id);
                                RESULT.setLine(idleft);
                                RESULT.setColumn(idright);
                            :}
                         | IDENTIFIER LPAREN ExprList RPAREN /* TODO */
                         | IDENTIFIER LEFT_SQUARE Expr RIGHT_SQUARE /* TODO */
                         | Expr DOT IDENTIFIER/* TODO */
                         | Expr DOT IDENTIFIER LEFT_SQUARE Expr RIGHT_SQUARE/* TODO */
                         | LPAREN:lp Expr:e RPAREN
                            {:
                                RESULT = new ParenthesisExpression(e);
                                RESULT.setLine(lpleft);
                                RESULT.setColumn(lpright);
                            :}
                         | Expr:e1 PLUS Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.PLUS, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr:e1 MINUS Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.MINUS, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr:e1 TIMES Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.MULTIPLY, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr:e1 DIVISION Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.DIVISION, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr MODULUS Expr /* TODO */
                         | Expr:e1 EQUAL Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.EQUAL, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr:e1 NOT_EQUAL Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.NOT_EQUAL, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr:e1 LESS Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.LESS, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr:e1 LESS_EQ Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.LESS_EQ, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr:e1 GREATER Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.GREATER, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | Expr:e1 GREATER_EQ Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.GREATER_EQ, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e1right);
                            :}
                         | LNOT Expr:e
                            {:
                                RESULT = new BinaryExpression(Operator.LNOT, e);
                                RESULT.setLine(eleft);
                                RESULT.setColumn(eright);
                            :}
                         | Expr:e1 LOR Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.LOR, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e2right);
                            :}
                         | Expr:e1 LAND Expr:e2
                            {:
                                RESULT = new BinaryExpression(Operator.LAND, e1, e2);
                                RESULT.setLine(e1left);
                                RESULT.setColumn(e2right);
                            :}
                         | MINUS:m Expr:e 
                            {:
                                RESULT = new UnaryExpression(Operator.MINUS, e);
                                RESULT.setLine(mleft);
                                RESULT.setColumn(mright);
                            :}
                            %prec UMINUS
                         ;
ExprList               ::= Expr
                         | ExprList COMMA Expr
                         ;
CompoundStmt           ::= LBRACKET:lb StmtList:sl RBRACKET
                            {:
                                RESULT = new CompoundStatement(sl);
                                RESULT.setLine(lbleft);
                                RESULT.setColumn(lbright);
                            :}
                         | LBRACKET:lb RBRACKET
                            {:
                                RESULT = new CompoundStatement();
                                RESULT.setLine(lbleft);
                                RESULT.setColumn(lbright);
                            :}
                         ;